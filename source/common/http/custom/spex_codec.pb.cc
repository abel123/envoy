// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: source/common/http/custom/spex_codec.proto

#include "source/common/http/custom/spex_codec.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace sp {
namespace common {
constexpr SpexCodec::SpexCodec(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct SpexCodecDefaultTypeInternal {
  constexpr SpexCodecDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SpexCodecDefaultTypeInternal() {}
  union {
    SpexCodec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SpexCodecDefaultTypeInternal _SpexCodec_default_instance_;
constexpr Constant::Constant(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ConstantDefaultTypeInternal {
  constexpr ConstantDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ConstantDefaultTypeInternal() {}
  union {
    Constant _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ConstantDefaultTypeInternal _Constant_default_instance_;
constexpr SpexHeader::SpexHeader(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , command_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , source_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , destination_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , span_context_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , qos_(nullptr)
  , status_(nullptr)
  , flag_(0u)
  , version_(0u)
  , timestamp_(uint64_t{0u})
  , error_(0u)
  , content_type_(0u)
  , session_id_(int64_t{0}){}
struct SpexHeaderDefaultTypeInternal {
  constexpr SpexHeaderDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SpexHeaderDefaultTypeInternal() {}
  union {
    SpexHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SpexHeaderDefaultTypeInternal _SpexHeader_default_instance_;
constexpr SpexHeaderQoS::SpexHeaderQoS(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : priority_(0u)
  , timeout_(0u){}
struct SpexHeaderQoSDefaultTypeInternal {
  constexpr SpexHeaderQoSDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SpexHeaderQoSDefaultTypeInternal() {}
  union {
    SpexHeaderQoS _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SpexHeaderQoSDefaultTypeInternal _SpexHeaderQoS_default_instance_;
constexpr Any::Any(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : type_url_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , value_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct AnyDefaultTypeInternal {
  constexpr AnyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AnyDefaultTypeInternal() {}
  union {
    Any _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AnyDefaultTypeInternal _Any_default_instance_;
constexpr Status::Status(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : details_()
  , message_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , code_(0u){}
struct StatusDefaultTypeInternal {
  constexpr StatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StatusDefaultTypeInternal() {}
  union {
    Status _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StatusDefaultTypeInternal _Status_default_instance_;
constexpr KeepAliveRequest::KeepAliveRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : opaque_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , extra_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , health_status_(0u){}
struct KeepAliveRequestDefaultTypeInternal {
  constexpr KeepAliveRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~KeepAliveRequestDefaultTypeInternal() {}
  union {
    KeepAliveRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT KeepAliveRequestDefaultTypeInternal _KeepAliveRequest_default_instance_;
constexpr KeepAliveResponse::KeepAliveResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct KeepAliveResponseDefaultTypeInternal {
  constexpr KeepAliveResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~KeepAliveResponseDefaultTypeInternal() {}
  union {
    KeepAliveResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT KeepAliveResponseDefaultTypeInternal _KeepAliveResponse_default_instance_;
constexpr KV::KV(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , value_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct KVDefaultTypeInternal {
  constexpr KVDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~KVDefaultTypeInternal() {}
  union {
    KV _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT KVDefaultTypeInternal _KV_default_instance_;
constexpr Metadata::Metadata(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : kvs_(){}
struct MetadataDefaultTypeInternal {
  constexpr MetadataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MetadataDefaultTypeInternal() {}
  union {
    Metadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MetadataDefaultTypeInternal _Metadata_default_instance_;
}  // namespace common
}  // namespace sp
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto[10];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto[5];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto = nullptr;

const uint32_t TableStruct_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sp::common::SpexCodec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sp::common::Constant, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sp::common::SpexHeader, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::sp::common::SpexHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sp::common::SpexHeader, id_),
  PROTOBUF_FIELD_OFFSET(::sp::common::SpexHeader, flag_),
  PROTOBUF_FIELD_OFFSET(::sp::common::SpexHeader, key_),
  PROTOBUF_FIELD_OFFSET(::sp::common::SpexHeader, command_),
  PROTOBUF_FIELD_OFFSET(::sp::common::SpexHeader, source_),
  PROTOBUF_FIELD_OFFSET(::sp::common::SpexHeader, timestamp_),
  PROTOBUF_FIELD_OFFSET(::sp::common::SpexHeader, version_),
  PROTOBUF_FIELD_OFFSET(::sp::common::SpexHeader, error_),
  PROTOBUF_FIELD_OFFSET(::sp::common::SpexHeader, qos_),
  PROTOBUF_FIELD_OFFSET(::sp::common::SpexHeader, destination_),
  PROTOBUF_FIELD_OFFSET(::sp::common::SpexHeader, content_type_),
  PROTOBUF_FIELD_OFFSET(::sp::common::SpexHeader, span_context_),
  PROTOBUF_FIELD_OFFSET(::sp::common::SpexHeader, session_id_),
  PROTOBUF_FIELD_OFFSET(::sp::common::SpexHeader, status_),
  0,
  8,
  1,
  2,
  3,
  10,
  9,
  11,
  6,
  4,
  12,
  5,
  13,
  7,
  PROTOBUF_FIELD_OFFSET(::sp::common::SpexHeaderQoS, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::sp::common::SpexHeaderQoS, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sp::common::SpexHeaderQoS, priority_),
  PROTOBUF_FIELD_OFFSET(::sp::common::SpexHeaderQoS, timeout_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::sp::common::Any, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::sp::common::Any, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sp::common::Any, type_url_),
  PROTOBUF_FIELD_OFFSET(::sp::common::Any, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::sp::common::Status, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::sp::common::Status, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sp::common::Status, code_),
  PROTOBUF_FIELD_OFFSET(::sp::common::Status, message_),
  PROTOBUF_FIELD_OFFSET(::sp::common::Status, details_),
  1,
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::sp::common::KeepAliveRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::sp::common::KeepAliveRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sp::common::KeepAliveRequest, opaque_),
  PROTOBUF_FIELD_OFFSET(::sp::common::KeepAliveRequest, health_status_),
  PROTOBUF_FIELD_OFFSET(::sp::common::KeepAliveRequest, extra_data_),
  0,
  2,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sp::common::KeepAliveResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sp::common::KV, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::sp::common::KV, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sp::common::KV, key_),
  PROTOBUF_FIELD_OFFSET(::sp::common::KV, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sp::common::Metadata, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sp::common::Metadata, kvs_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::sp::common::SpexCodec)},
  { 6, -1, -1, sizeof(::sp::common::Constant)},
  { 12, 32, -1, sizeof(::sp::common::SpexHeader)},
  { 46, 54, -1, sizeof(::sp::common::SpexHeaderQoS)},
  { 56, 64, -1, sizeof(::sp::common::Any)},
  { 66, 75, -1, sizeof(::sp::common::Status)},
  { 78, 87, -1, sizeof(::sp::common::KeepAliveRequest)},
  { 90, -1, -1, sizeof(::sp::common::KeepAliveResponse)},
  { 96, 104, -1, sizeof(::sp::common::KV)},
  { 106, -1, -1, sizeof(::sp::common::Metadata)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::sp::common::_SpexCodec_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::sp::common::_Constant_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::sp::common::_SpexHeader_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::sp::common::_SpexHeaderQoS_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::sp::common::_Any_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::sp::common::_Status_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::sp::common::_KeepAliveRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::sp::common::_KeepAliveResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::sp::common::_KV_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::sp::common::_Metadata_default_instance_),
};

const char descriptor_table_protodef_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n*source/common/http/custom/spex_codec.p"
  "roto\022\tsp.common\"\013\n\tSpexCodec\"\305\014\n\010Constan"
  "t\"\244\n\n\tErrorCode\022\013\n\007SUCCESS\020\000\022\025\n\021ERROR_SP"
  "_NOT_INIT\020d\022\026\n\022ERROR_SP_NEED_AUTH\020e\022 \n\034E"
  "RROR_SP_SERVICE_UNAVAILABLE\020f\022\031\n\025ERROR_S"
  "P_SERVICE_BUSY\020g\022\036\n\032ERROR_SP_SERVICE_NOT"
  "_FOUND\020h\022\023\n\017ERROR_SP_PARAMS\020i\022\023\n\017ERROR_S"
  "P_HEADER\020j\022\024\n\020ERROR_SP_TIMEOUT\020k\022 \n\034ERRO"
  "R_SP_INSTANCE_DUPLICATED\020l\022\025\n\021ERROR_SP_O"
  "VERLOAD\020m\022\035\n\031ERROR_SP_SERVE_PERMISSION\020n"
  "\022\036\n\032ERROR_SP_ACCESS_PERMISSION\020o\022\025\n\021ERRO"
  "R_SP_INTERNAL\020p\022\035\n\031ERROR_SP_SPEX_UNAVAIL"
  "ABLE\020q\022\021\n\rERROR_SP_BODY\020r\022\032\n\026ERROR_SP_PF"
  "B_NOT_FOUND\020s\022\035\n\031ERROR_SP_SUBSET_NOT_FOU"
  "ND\020t\022\031\n\025ERROR_SP_SPEX_NETWORK\020u\022\034\n\030ERROR"
  "_SP_SPCON_SUBSCRIBE\020v\022\030\n\024ERROR_SP_SPROUT"
  "_AUTH\020w\022\034\n\030ERROR_SP_SPROUT_REGISTER\020x\022\032\n"
  "\026ERROR_SP_SPROUT_NOTIFY\020y\022\035\n\031ERROR_SP_SP"
  "ROUT_KEEPALIVE\020z\022\031\n\025ERROR_SP_SPROUT_LEAS"
  "E\020{\022\032\n\026ERROR_SP_EMPTY_ROUTING\020|\022\033\n\027ERROR"
  "_SP_RULE_NOT_FOUND\020}\022\035\n\030ERROR_SP_SERIVCE"
  "_OFFLINE\020\250F\022\033\n\026ERROR_SP_SERIVCE_ERROR\020\251F"
  "\022\022\n\rERROR_UNKNOWN\020\220N\022\023\n\016ERROR_NOT_INIT\020\221"
  "N\022\021\n\014ERROR_PARAMS\020\222N\022\025\n\020ERROR_PERMISSION"
  "\020\223N\022\022\n\rERROR_TIMEOUT\020\224N\022\021\n\014ERROR_SYSTEM\020"
  "\225N\022\026\n\021ERROR_QUOTA_LIMIT\020\226N\022\032\n\025ERROR_NOT_"
  "IMPLEMENTED\020\227N\022\025\n\020ERROR_DEPRECATED\020\230N\022\036\n"
  "\031ERROR_SERVICE_UNAVAILABLE\020\231N\022\027\n\022ERROR_S"
  "ERVICE_BUSY\020\232N\022\033\n\026ERROR_SERVICE_INTERNAL"
  "\020\233N\022\024\n\017ERROR_NEED_AUTH\020\234N\022\024\n\017ERROR_NOT_F"
  "OUND\020\235N\022\031\n\024ERROR_ENTITY_EXISTED\020\236N\022\027\n\022ER"
  "ROR_EXCEED_LIMIT\020\237N\022\033\n\026ERROR_SERVICE_OVE"
  "RLOAD\020\240N\022\032\n\025ERROR_EARLY_REJECTION\020\241N\022\"\n\035"
  "ERROR_CIRCUIT_BREAKER_TRIPPED\020\242N\022\030\n\023ERRO"
  "R_AEGIS_DROPPED\020\330O\022\024\n\017ERROR_BIZ_ERROR\020\274P"
  "\"0\n\016SpexHeaderFlag\022\017\n\013RPC_REQUEST\020\000\022\r\n\tR"
  "PC_REPLY\020\001\"\\\n\025SpexHeaderFlagBitmask\022\034\n\030H"
  "EADER_BITMASK_RPC_REPLY\020\001\022%\n!HEADER_BITM"
  "ASK_APPLICATION_HEADER\020\002\"\201\001\n\025SpexHeaderC"
  "ontentType\022\031\n\025CONTENT_TYPE_PROTOBUF\020\000\022\025\n"
  "\021CONTENT_TYPE_JSON\020\001\022\025\n\021CONTENT_TYPE_HTT"
  "P\020\002\022\037\n\031CONTENT_TYPE_CUSTOM_START\020\200\200\004\"\246\002\n"
  "\nSpexHeader\022\n\n\002id\030\001 \001(\014\022\014\n\004flag\030\002 \001(\r\022\013\n"
  "\003key\030\003 \001(\t\022\017\n\007command\030\004 \001(\t\022\016\n\006source\030\005 "
  "\001(\t\022\021\n\ttimestamp\030\006 \001(\004\022\017\n\007version\030\007 \001(\r\022"
  "\r\n\005error\030\010 \001(\r\022%\n\003qos\030\t \001(\0132\030.sp.common."
  "SpexHeaderQoS\022\023\n\013destination\030\n \001(\t\022\024\n\014co"
  "ntent_type\030\013 \001(\r\022\024\n\014span_context\030\014 \001(\t\022\022"
  "\n\nsession_id\030\r \001(\003\022!\n\006status\030\016 \001(\0132\021.sp."
  "common.Status\"2\n\rSpexHeaderQoS\022\020\n\010priori"
  "ty\030\001 \001(\r\022\017\n\007timeout\030\002 \001(\r\"&\n\003Any\022\020\n\010type"
  "_url\030\001 \001(\t\022\r\n\005value\030\002 \001(\014\"H\n\006Status\022\014\n\004c"
  "ode\030\001 \001(\r\022\017\n\007message\030\002 \001(\t\022\037\n\007details\030\003 "
  "\003(\0132\016.sp.common.Any\"M\n\020KeepAliveRequest\022"
  "\016\n\006opaque\030\001 \001(\t\022\025\n\rhealth_status\030\002 \001(\r\022\022"
  "\n\nextra_data\030\003 \001(\014\"\023\n\021KeepAliveResponse\""
  " \n\002KV\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t\"&\n\010Met"
  "adata\022\032\n\003kvs\030\001 \003(\0132\r.sp.common.KV*P\n\016Ins"
  "tanceStatus\022\006\n\002UP\020\000\022\010\n\004DOWN\020\001\022\r\n\tFORCED_"
  "UP\020\002\022\017\n\013FORCED_DOWN\020\003\022\014\n\010STARTING\020\004"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto = {
  false, false, 2395, descriptor_table_protodef_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto, "source/common/http/custom/spex_codec.proto", 
  &descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto_once, nullptr, 0, 10,
  schemas, file_default_instances, TableStruct_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto::offsets,
  file_level_metadata_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto, file_level_enum_descriptors_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto, file_level_service_descriptors_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto_getter() {
  return &descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto(&descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto);
namespace sp {
namespace common {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Constant_ErrorCode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto);
  return file_level_enum_descriptors_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto[0];
}
bool Constant_ErrorCode_IsValid(int value) {
  switch (value) {
    case 0:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 125:
    case 9000:
    case 9001:
    case 10000:
    case 10001:
    case 10002:
    case 10003:
    case 10004:
    case 10005:
    case 10006:
    case 10007:
    case 10008:
    case 10009:
    case 10010:
    case 10011:
    case 10012:
    case 10013:
    case 10014:
    case 10015:
    case 10016:
    case 10017:
    case 10018:
    case 10200:
    case 10300:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Constant_ErrorCode Constant::SUCCESS;
constexpr Constant_ErrorCode Constant::ERROR_SP_NOT_INIT;
constexpr Constant_ErrorCode Constant::ERROR_SP_NEED_AUTH;
constexpr Constant_ErrorCode Constant::ERROR_SP_SERVICE_UNAVAILABLE;
constexpr Constant_ErrorCode Constant::ERROR_SP_SERVICE_BUSY;
constexpr Constant_ErrorCode Constant::ERROR_SP_SERVICE_NOT_FOUND;
constexpr Constant_ErrorCode Constant::ERROR_SP_PARAMS;
constexpr Constant_ErrorCode Constant::ERROR_SP_HEADER;
constexpr Constant_ErrorCode Constant::ERROR_SP_TIMEOUT;
constexpr Constant_ErrorCode Constant::ERROR_SP_INSTANCE_DUPLICATED;
constexpr Constant_ErrorCode Constant::ERROR_SP_OVERLOAD;
constexpr Constant_ErrorCode Constant::ERROR_SP_SERVE_PERMISSION;
constexpr Constant_ErrorCode Constant::ERROR_SP_ACCESS_PERMISSION;
constexpr Constant_ErrorCode Constant::ERROR_SP_INTERNAL;
constexpr Constant_ErrorCode Constant::ERROR_SP_SPEX_UNAVAILABLE;
constexpr Constant_ErrorCode Constant::ERROR_SP_BODY;
constexpr Constant_ErrorCode Constant::ERROR_SP_PFB_NOT_FOUND;
constexpr Constant_ErrorCode Constant::ERROR_SP_SUBSET_NOT_FOUND;
constexpr Constant_ErrorCode Constant::ERROR_SP_SPEX_NETWORK;
constexpr Constant_ErrorCode Constant::ERROR_SP_SPCON_SUBSCRIBE;
constexpr Constant_ErrorCode Constant::ERROR_SP_SPROUT_AUTH;
constexpr Constant_ErrorCode Constant::ERROR_SP_SPROUT_REGISTER;
constexpr Constant_ErrorCode Constant::ERROR_SP_SPROUT_NOTIFY;
constexpr Constant_ErrorCode Constant::ERROR_SP_SPROUT_KEEPALIVE;
constexpr Constant_ErrorCode Constant::ERROR_SP_SPROUT_LEASE;
constexpr Constant_ErrorCode Constant::ERROR_SP_EMPTY_ROUTING;
constexpr Constant_ErrorCode Constant::ERROR_SP_RULE_NOT_FOUND;
constexpr Constant_ErrorCode Constant::ERROR_SP_SERIVCE_OFFLINE;
constexpr Constant_ErrorCode Constant::ERROR_SP_SERIVCE_ERROR;
constexpr Constant_ErrorCode Constant::ERROR_UNKNOWN;
constexpr Constant_ErrorCode Constant::ERROR_NOT_INIT;
constexpr Constant_ErrorCode Constant::ERROR_PARAMS;
constexpr Constant_ErrorCode Constant::ERROR_PERMISSION;
constexpr Constant_ErrorCode Constant::ERROR_TIMEOUT;
constexpr Constant_ErrorCode Constant::ERROR_SYSTEM;
constexpr Constant_ErrorCode Constant::ERROR_QUOTA_LIMIT;
constexpr Constant_ErrorCode Constant::ERROR_NOT_IMPLEMENTED;
constexpr Constant_ErrorCode Constant::ERROR_DEPRECATED;
constexpr Constant_ErrorCode Constant::ERROR_SERVICE_UNAVAILABLE;
constexpr Constant_ErrorCode Constant::ERROR_SERVICE_BUSY;
constexpr Constant_ErrorCode Constant::ERROR_SERVICE_INTERNAL;
constexpr Constant_ErrorCode Constant::ERROR_NEED_AUTH;
constexpr Constant_ErrorCode Constant::ERROR_NOT_FOUND;
constexpr Constant_ErrorCode Constant::ERROR_ENTITY_EXISTED;
constexpr Constant_ErrorCode Constant::ERROR_EXCEED_LIMIT;
constexpr Constant_ErrorCode Constant::ERROR_SERVICE_OVERLOAD;
constexpr Constant_ErrorCode Constant::ERROR_EARLY_REJECTION;
constexpr Constant_ErrorCode Constant::ERROR_CIRCUIT_BREAKER_TRIPPED;
constexpr Constant_ErrorCode Constant::ERROR_AEGIS_DROPPED;
constexpr Constant_ErrorCode Constant::ERROR_BIZ_ERROR;
constexpr Constant_ErrorCode Constant::ErrorCode_MIN;
constexpr Constant_ErrorCode Constant::ErrorCode_MAX;
constexpr int Constant::ErrorCode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Constant_SpexHeaderFlag_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto);
  return file_level_enum_descriptors_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto[1];
}
bool Constant_SpexHeaderFlag_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Constant_SpexHeaderFlag Constant::RPC_REQUEST;
constexpr Constant_SpexHeaderFlag Constant::RPC_REPLY;
constexpr Constant_SpexHeaderFlag Constant::SpexHeaderFlag_MIN;
constexpr Constant_SpexHeaderFlag Constant::SpexHeaderFlag_MAX;
constexpr int Constant::SpexHeaderFlag_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Constant_SpexHeaderFlagBitmask_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto);
  return file_level_enum_descriptors_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto[2];
}
bool Constant_SpexHeaderFlagBitmask_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Constant_SpexHeaderFlagBitmask Constant::HEADER_BITMASK_RPC_REPLY;
constexpr Constant_SpexHeaderFlagBitmask Constant::HEADER_BITMASK_APPLICATION_HEADER;
constexpr Constant_SpexHeaderFlagBitmask Constant::SpexHeaderFlagBitmask_MIN;
constexpr Constant_SpexHeaderFlagBitmask Constant::SpexHeaderFlagBitmask_MAX;
constexpr int Constant::SpexHeaderFlagBitmask_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Constant_SpexHeaderContentType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto);
  return file_level_enum_descriptors_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto[3];
}
bool Constant_SpexHeaderContentType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 65536:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Constant_SpexHeaderContentType Constant::CONTENT_TYPE_PROTOBUF;
constexpr Constant_SpexHeaderContentType Constant::CONTENT_TYPE_JSON;
constexpr Constant_SpexHeaderContentType Constant::CONTENT_TYPE_HTTP;
constexpr Constant_SpexHeaderContentType Constant::CONTENT_TYPE_CUSTOM_START;
constexpr Constant_SpexHeaderContentType Constant::SpexHeaderContentType_MIN;
constexpr Constant_SpexHeaderContentType Constant::SpexHeaderContentType_MAX;
constexpr int Constant::SpexHeaderContentType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InstanceStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto);
  return file_level_enum_descriptors_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto[4];
}
bool InstanceStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class SpexCodec::_Internal {
 public:
};

SpexCodec::SpexCodec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:sp.common.SpexCodec)
}
SpexCodec::SpexCodec(const SpexCodec& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:sp.common.SpexCodec)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpexCodec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpexCodec::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata SpexCodec::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto_getter, &descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto_once,
      file_level_metadata_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto[0]);
}

// ===================================================================

class Constant::_Internal {
 public:
};

Constant::Constant(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:sp.common.Constant)
}
Constant::Constant(const Constant& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:sp.common.Constant)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Constant::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Constant::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Constant::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto_getter, &descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto_once,
      file_level_metadata_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto[1]);
}

// ===================================================================

class SpexHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<SpexHeader>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_flag(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_command(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_source(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::sp::common::SpexHeaderQoS& qos(const SpexHeader* msg);
  static void set_has_qos(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_destination(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_content_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_span_context(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::sp::common::Status& status(const SpexHeader* msg);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::sp::common::SpexHeaderQoS&
SpexHeader::_Internal::qos(const SpexHeader* msg) {
  return *msg->qos_;
}
const ::sp::common::Status&
SpexHeader::_Internal::status(const SpexHeader* msg) {
  return *msg->status_;
}
SpexHeader::SpexHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:sp.common.SpexHeader)
}
SpexHeader::SpexHeader(const SpexHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_id()) {
    id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_id(), 
      GetArenaForAllocation());
  }
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key()) {
    key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_key(), 
      GetArenaForAllocation());
  }
  command_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    command_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_command()) {
    command_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_command(), 
      GetArenaForAllocation());
  }
  source_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    source_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_source()) {
    source_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_source(), 
      GetArenaForAllocation());
  }
  destination_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    destination_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_destination()) {
    destination_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_destination(), 
      GetArenaForAllocation());
  }
  span_context_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    span_context_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_span_context()) {
    span_context_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_span_context(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_qos()) {
    qos_ = new ::sp::common::SpexHeaderQoS(*from.qos_);
  } else {
    qos_ = nullptr;
  }
  if (from._internal_has_status()) {
    status_ = new ::sp::common::Status(*from.status_);
  } else {
    status_ = nullptr;
  }
  ::memcpy(&flag_, &from.flag_,
    static_cast<size_t>(reinterpret_cast<char*>(&session_id_) -
    reinterpret_cast<char*>(&flag_)) + sizeof(session_id_));
  // @@protoc_insertion_point(copy_constructor:sp.common.SpexHeader)
}

inline void SpexHeader::SharedCtor() {
id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
command_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  command_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
source_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  source_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
destination_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  destination_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
span_context_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  span_context_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&qos_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&session_id_) -
    reinterpret_cast<char*>(&qos_)) + sizeof(session_id_));
}

SpexHeader::~SpexHeader() {
  // @@protoc_insertion_point(destructor:sp.common.SpexHeader)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SpexHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  command_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  source_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  destination_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  span_context_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete qos_;
  if (this != internal_default_instance()) delete status_;
}

void SpexHeader::ArenaDtor(void* object) {
  SpexHeader* _this = reinterpret_cast< SpexHeader* >(object);
  (void)_this;
}
void SpexHeader::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SpexHeader::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SpexHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:sp.common.SpexHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      command_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      source_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      destination_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      span_context_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(qos_ != nullptr);
      qos_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(status_ != nullptr);
      status_->Clear();
    }
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&flag_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&session_id_) -
        reinterpret_cast<char*>(&flag_)) + sizeof(session_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpexHeader::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flag = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_flag(&has_bits);
          flag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string key = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "sp.common.SpexHeader.key");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string command = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_command();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "sp.common.SpexHeader.command");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string source = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_source();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "sp.common.SpexHeader.source");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 timestamp = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 version = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 error = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_error(&has_bits);
          error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sp.common.SpexHeaderQoS qos = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_qos(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string destination = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_destination();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "sp.common.SpexHeader.destination");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 content_type = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_content_type(&has_bits);
          content_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string span_context = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_span_context();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "sp.common.SpexHeader.span_context");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 session_id = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_session_id(&has_bits);
          session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sp.common.Status status = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SpexHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sp.common.SpexHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_id(), target);
  }

  // optional uint32 flag = 2;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_flag(), target);
  }

  // optional string key = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "sp.common.SpexHeader.key");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_key(), target);
  }

  // optional string command = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_command().data(), static_cast<int>(this->_internal_command().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "sp.common.SpexHeader.command");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_command(), target);
  }

  // optional string source = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_source().data(), static_cast<int>(this->_internal_source().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "sp.common.SpexHeader.source");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_source(), target);
  }

  // optional uint64 timestamp = 6;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_timestamp(), target);
  }

  // optional uint32 version = 7;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_version(), target);
  }

  // optional uint32 error = 8;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_error(), target);
  }

  // optional .sp.common.SpexHeaderQoS qos = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::qos(this), target, stream);
  }

  // optional string destination = 10;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_destination().data(), static_cast<int>(this->_internal_destination().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "sp.common.SpexHeader.destination");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_destination(), target);
  }

  // optional uint32 content_type = 11;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(11, this->_internal_content_type(), target);
  }

  // optional string span_context = 12;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_span_context().data(), static_cast<int>(this->_internal_span_context().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "sp.common.SpexHeader.span_context");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_span_context(), target);
  }

  // optional int64 session_id = 13;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(13, this->_internal_session_id(), target);
  }

  // optional .sp.common.Status status = 14;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        14, _Internal::status(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sp.common.SpexHeader)
  return target;
}

size_t SpexHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sp.common.SpexHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_id());
    }

    // optional string key = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_key());
    }

    // optional string command = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_command());
    }

    // optional string source = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_source());
    }

    // optional string destination = 10;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_destination());
    }

    // optional string span_context = 12;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_span_context());
    }

    // optional .sp.common.SpexHeaderQoS qos = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *qos_);
    }

    // optional .sp.common.Status status = 14;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *status_);
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional uint32 flag = 2;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_flag());
    }

    // optional uint32 version = 7;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
    }

    // optional uint64 timestamp = 6;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_timestamp());
    }

    // optional uint32 error = 8;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_error());
    }

    // optional uint32 content_type = 11;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_content_type());
    }

    // optional int64 session_id = 13;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_session_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpexHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SpexHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpexHeader::GetClassData() const { return &_class_data_; }

void SpexHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SpexHeader *>(to)->MergeFrom(
      static_cast<const SpexHeader &>(from));
}


void SpexHeader::MergeFrom(const SpexHeader& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sp.common.SpexHeader)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_command(from._internal_command());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_source(from._internal_source());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_destination(from._internal_destination());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_span_context(from._internal_span_context());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_qos()->::sp::common::SpexHeaderQoS::MergeFrom(from._internal_qos());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_status()->::sp::common::Status::MergeFrom(from._internal_status());
    }
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      flag_ = from.flag_;
    }
    if (cached_has_bits & 0x00000200u) {
      version_ = from.version_;
    }
    if (cached_has_bits & 0x00000400u) {
      timestamp_ = from.timestamp_;
    }
    if (cached_has_bits & 0x00000800u) {
      error_ = from.error_;
    }
    if (cached_has_bits & 0x00001000u) {
      content_type_ = from.content_type_;
    }
    if (cached_has_bits & 0x00002000u) {
      session_id_ = from.session_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpexHeader::CopyFrom(const SpexHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sp.common.SpexHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpexHeader::IsInitialized() const {
  return true;
}

void SpexHeader::InternalSwap(SpexHeader* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &id_, lhs_arena,
      &other->id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &key_, lhs_arena,
      &other->key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &command_, lhs_arena,
      &other->command_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &source_, lhs_arena,
      &other->source_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &destination_, lhs_arena,
      &other->destination_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &span_context_, lhs_arena,
      &other->span_context_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SpexHeader, session_id_)
      + sizeof(SpexHeader::session_id_)
      - PROTOBUF_FIELD_OFFSET(SpexHeader, qos_)>(
          reinterpret_cast<char*>(&qos_),
          reinterpret_cast<char*>(&other->qos_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SpexHeader::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto_getter, &descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto_once,
      file_level_metadata_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto[2]);
}

// ===================================================================

class SpexHeaderQoS::_Internal {
 public:
  using HasBits = decltype(std::declval<SpexHeaderQoS>()._has_bits_);
  static void set_has_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_timeout(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

SpexHeaderQoS::SpexHeaderQoS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:sp.common.SpexHeaderQoS)
}
SpexHeaderQoS::SpexHeaderQoS(const SpexHeaderQoS& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&priority_, &from.priority_,
    static_cast<size_t>(reinterpret_cast<char*>(&timeout_) -
    reinterpret_cast<char*>(&priority_)) + sizeof(timeout_));
  // @@protoc_insertion_point(copy_constructor:sp.common.SpexHeaderQoS)
}

inline void SpexHeaderQoS::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&priority_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&timeout_) -
    reinterpret_cast<char*>(&priority_)) + sizeof(timeout_));
}

SpexHeaderQoS::~SpexHeaderQoS() {
  // @@protoc_insertion_point(destructor:sp.common.SpexHeaderQoS)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SpexHeaderQoS::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SpexHeaderQoS::ArenaDtor(void* object) {
  SpexHeaderQoS* _this = reinterpret_cast< SpexHeaderQoS* >(object);
  (void)_this;
}
void SpexHeaderQoS::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SpexHeaderQoS::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SpexHeaderQoS::Clear() {
// @@protoc_insertion_point(message_clear_start:sp.common.SpexHeaderQoS)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&priority_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&timeout_) -
        reinterpret_cast<char*>(&priority_)) + sizeof(timeout_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpexHeaderQoS::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 priority = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_priority(&has_bits);
          priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 timeout = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_timeout(&has_bits);
          timeout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SpexHeaderQoS::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sp.common.SpexHeaderQoS)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 priority = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_priority(), target);
  }

  // optional uint32 timeout = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_timeout(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sp.common.SpexHeaderQoS)
  return target;
}

size_t SpexHeaderQoS::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sp.common.SpexHeaderQoS)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 priority = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_priority());
    }

    // optional uint32 timeout = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_timeout());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpexHeaderQoS::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SpexHeaderQoS::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpexHeaderQoS::GetClassData() const { return &_class_data_; }

void SpexHeaderQoS::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SpexHeaderQoS *>(to)->MergeFrom(
      static_cast<const SpexHeaderQoS &>(from));
}


void SpexHeaderQoS::MergeFrom(const SpexHeaderQoS& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sp.common.SpexHeaderQoS)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      priority_ = from.priority_;
    }
    if (cached_has_bits & 0x00000002u) {
      timeout_ = from.timeout_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpexHeaderQoS::CopyFrom(const SpexHeaderQoS& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sp.common.SpexHeaderQoS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpexHeaderQoS::IsInitialized() const {
  return true;
}

void SpexHeaderQoS::InternalSwap(SpexHeaderQoS* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SpexHeaderQoS, timeout_)
      + sizeof(SpexHeaderQoS::timeout_)
      - PROTOBUF_FIELD_OFFSET(SpexHeaderQoS, priority_)>(
          reinterpret_cast<char*>(&priority_),
          reinterpret_cast<char*>(&other->priority_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SpexHeaderQoS::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto_getter, &descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto_once,
      file_level_metadata_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto[3]);
}

// ===================================================================

class Any::_Internal {
 public:
  using HasBits = decltype(std::declval<Any>()._has_bits_);
  static void set_has_type_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Any::Any(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:sp.common.Any)
}
Any::Any(const Any& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  type_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type_url()) {
    type_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_type_url(), 
      GetArenaForAllocation());
  }
  value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_value(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:sp.common.Any)
}

inline void Any::SharedCtor() {
type_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Any::~Any() {
  // @@protoc_insertion_point(destructor:sp.common.Any)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Any::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  type_url_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Any::ArenaDtor(void* object) {
  Any* _this = reinterpret_cast< Any* >(object);
  (void)_this;
}
void Any::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Any::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Any::Clear() {
// @@protoc_insertion_point(message_clear_start:sp.common.Any)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      type_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      value_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Any::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string type_url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type_url();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "sp.common.Any.type_url");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Any::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sp.common.Any)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string type_url = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_type_url().data(), static_cast<int>(this->_internal_type_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "sp.common.Any.type_url");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type_url(), target);
  }

  // optional bytes value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sp.common.Any)
  return target;
}

size_t Any::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sp.common.Any)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string type_url = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_type_url());
    }

    // optional bytes value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_value());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Any::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Any::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Any::GetClassData() const { return &_class_data_; }

void Any::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Any *>(to)->MergeFrom(
      static_cast<const Any &>(from));
}


void Any::MergeFrom(const Any& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sp.common.Any)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_type_url(from._internal_type_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_value(from._internal_value());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Any::CopyFrom(const Any& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sp.common.Any)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Any::IsInitialized() const {
  return true;
}

void Any::InternalSwap(Any* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &type_url_, lhs_arena,
      &other->type_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &value_, lhs_arena,
      &other->value_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Any::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto_getter, &descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto_once,
      file_level_metadata_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto[4]);
}

// ===================================================================

class Status::_Internal {
 public:
  using HasBits = decltype(std::declval<Status>()._has_bits_);
  static void set_has_code(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Status::Status(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  details_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:sp.common.Status)
}
Status::Status(const Status& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      details_(from.details_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_message(), 
      GetArenaForAllocation());
  }
  code_ = from.code_;
  // @@protoc_insertion_point(copy_constructor:sp.common.Status)
}

inline void Status::SharedCtor() {
message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
code_ = 0u;
}

Status::~Status() {
  // @@protoc_insertion_point(destructor:sp.common.Status)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Status::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Status::ArenaDtor(void* object) {
  Status* _this = reinterpret_cast< Status* >(object);
  (void)_this;
}
void Status::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Status::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Status::Clear() {
// @@protoc_insertion_point(message_clear_start:sp.common.Status)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  details_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    message_.ClearNonDefaultToEmpty();
  }
  code_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Status::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_code(&has_bits);
          code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "sp.common.Status.message");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .sp.common.Any details = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_details(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Status::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sp.common.Status)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 code = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_code(), target);
  }

  // optional string message = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "sp.common.Status.message");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_message(), target);
  }

  // repeated .sp.common.Any details = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_details_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_details(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sp.common.Status)
  return target;
}

size_t Status::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sp.common.Status)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .sp.common.Any details = 3;
  total_size += 1UL * this->_internal_details_size();
  for (const auto& msg : this->details_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string message = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_message());
    }

    // optional uint32 code = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_code());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Status::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Status::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Status::GetClassData() const { return &_class_data_; }

void Status::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Status *>(to)->MergeFrom(
      static_cast<const Status &>(from));
}


void Status::MergeFrom(const Status& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sp.common.Status)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  details_.MergeFrom(from.details_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      code_ = from.code_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Status::CopyFrom(const Status& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sp.common.Status)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Status::IsInitialized() const {
  return true;
}

void Status::InternalSwap(Status* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  details_.InternalSwap(&other->details_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &message_, lhs_arena,
      &other->message_, rhs_arena
  );
  swap(code_, other->code_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Status::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto_getter, &descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto_once,
      file_level_metadata_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto[5]);
}

// ===================================================================

class KeepAliveRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<KeepAliveRequest>()._has_bits_);
  static void set_has_opaque(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_health_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_extra_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

KeepAliveRequest::KeepAliveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:sp.common.KeepAliveRequest)
}
KeepAliveRequest::KeepAliveRequest(const KeepAliveRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  opaque_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    opaque_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_opaque()) {
    opaque_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_opaque(), 
      GetArenaForAllocation());
  }
  extra_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    extra_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_extra_data()) {
    extra_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_extra_data(), 
      GetArenaForAllocation());
  }
  health_status_ = from.health_status_;
  // @@protoc_insertion_point(copy_constructor:sp.common.KeepAliveRequest)
}

inline void KeepAliveRequest::SharedCtor() {
opaque_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  opaque_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
extra_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  extra_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
health_status_ = 0u;
}

KeepAliveRequest::~KeepAliveRequest() {
  // @@protoc_insertion_point(destructor:sp.common.KeepAliveRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void KeepAliveRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  opaque_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  extra_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void KeepAliveRequest::ArenaDtor(void* object) {
  KeepAliveRequest* _this = reinterpret_cast< KeepAliveRequest* >(object);
  (void)_this;
}
void KeepAliveRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void KeepAliveRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KeepAliveRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:sp.common.KeepAliveRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      opaque_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      extra_data_.ClearNonDefaultToEmpty();
    }
  }
  health_status_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KeepAliveRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string opaque = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_opaque();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "sp.common.KeepAliveRequest.opaque");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 health_status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_health_status(&has_bits);
          health_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes extra_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_extra_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeepAliveRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sp.common.KeepAliveRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string opaque = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_opaque().data(), static_cast<int>(this->_internal_opaque().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "sp.common.KeepAliveRequest.opaque");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_opaque(), target);
  }

  // optional uint32 health_status = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_health_status(), target);
  }

  // optional bytes extra_data = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_extra_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sp.common.KeepAliveRequest)
  return target;
}

size_t KeepAliveRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sp.common.KeepAliveRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string opaque = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_opaque());
    }

    // optional bytes extra_data = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_extra_data());
    }

    // optional uint32 health_status = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_health_status());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KeepAliveRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    KeepAliveRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KeepAliveRequest::GetClassData() const { return &_class_data_; }

void KeepAliveRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<KeepAliveRequest *>(to)->MergeFrom(
      static_cast<const KeepAliveRequest &>(from));
}


void KeepAliveRequest::MergeFrom(const KeepAliveRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sp.common.KeepAliveRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_opaque(from._internal_opaque());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_extra_data(from._internal_extra_data());
    }
    if (cached_has_bits & 0x00000004u) {
      health_status_ = from.health_status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KeepAliveRequest::CopyFrom(const KeepAliveRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sp.common.KeepAliveRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeepAliveRequest::IsInitialized() const {
  return true;
}

void KeepAliveRequest::InternalSwap(KeepAliveRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &opaque_, lhs_arena,
      &other->opaque_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &extra_data_, lhs_arena,
      &other->extra_data_, rhs_arena
  );
  swap(health_status_, other->health_status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata KeepAliveRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto_getter, &descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto_once,
      file_level_metadata_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto[6]);
}

// ===================================================================

class KeepAliveResponse::_Internal {
 public:
};

KeepAliveResponse::KeepAliveResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:sp.common.KeepAliveResponse)
}
KeepAliveResponse::KeepAliveResponse(const KeepAliveResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:sp.common.KeepAliveResponse)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KeepAliveResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KeepAliveResponse::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata KeepAliveResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto_getter, &descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto_once,
      file_level_metadata_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto[7]);
}

// ===================================================================

class KV::_Internal {
 public:
  using HasBits = decltype(std::declval<KV>()._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

KV::KV(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:sp.common.KV)
}
KV::KV(const KV& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key()) {
    key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_key(), 
      GetArenaForAllocation());
  }
  value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_value(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:sp.common.KV)
}

inline void KV::SharedCtor() {
key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

KV::~KV() {
  // @@protoc_insertion_point(destructor:sp.common.KV)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void KV::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void KV::ArenaDtor(void* object) {
  KV* _this = reinterpret_cast< KV* >(object);
  (void)_this;
}
void KV::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void KV::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KV::Clear() {
// @@protoc_insertion_point(message_clear_start:sp.common.KV)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      value_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KV::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "sp.common.KV.key");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "sp.common.KV.value");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KV::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sp.common.KV)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string key = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "sp.common.KV.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // optional string value = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "sp.common.KV.value");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sp.common.KV)
  return target;
}

size_t KV::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sp.common.KV)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_key());
    }

    // optional string value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KV::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    KV::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KV::GetClassData() const { return &_class_data_; }

void KV::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<KV *>(to)->MergeFrom(
      static_cast<const KV &>(from));
}


void KV::MergeFrom(const KV& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sp.common.KV)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_value(from._internal_value());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KV::CopyFrom(const KV& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sp.common.KV)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KV::IsInitialized() const {
  return true;
}

void KV::InternalSwap(KV* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &key_, lhs_arena,
      &other->key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &value_, lhs_arena,
      &other->value_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata KV::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto_getter, &descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto_once,
      file_level_metadata_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto[8]);
}

// ===================================================================

class Metadata::_Internal {
 public:
};

Metadata::Metadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  kvs_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:sp.common.Metadata)
}
Metadata::Metadata(const Metadata& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      kvs_(from.kvs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:sp.common.Metadata)
}

inline void Metadata::SharedCtor() {
}

Metadata::~Metadata() {
  // @@protoc_insertion_point(destructor:sp.common.Metadata)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Metadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Metadata::ArenaDtor(void* object) {
  Metadata* _this = reinterpret_cast< Metadata* >(object);
  (void)_this;
}
void Metadata::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Metadata::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Metadata::Clear() {
// @@protoc_insertion_point(message_clear_start:sp.common.Metadata)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  kvs_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Metadata::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .sp.common.KV kvs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_kvs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Metadata::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sp.common.Metadata)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .sp.common.KV kvs = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_kvs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_kvs(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sp.common.Metadata)
  return target;
}

size_t Metadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sp.common.Metadata)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .sp.common.KV kvs = 1;
  total_size += 1UL * this->_internal_kvs_size();
  for (const auto& msg : this->kvs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Metadata::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Metadata::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Metadata::GetClassData() const { return &_class_data_; }

void Metadata::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Metadata *>(to)->MergeFrom(
      static_cast<const Metadata &>(from));
}


void Metadata::MergeFrom(const Metadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sp.common.Metadata)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  kvs_.MergeFrom(from.kvs_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Metadata::CopyFrom(const Metadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sp.common.Metadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Metadata::IsInitialized() const {
  return true;
}

void Metadata::InternalSwap(Metadata* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  kvs_.InternalSwap(&other->kvs_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Metadata::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto_getter, &descriptor_table_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto_once,
      file_level_metadata_source_2fcommon_2fhttp_2fcustom_2fspex_5fcodec_2eproto[9]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace common
}  // namespace sp
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::sp::common::SpexCodec* Arena::CreateMaybeMessage< ::sp::common::SpexCodec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sp::common::SpexCodec >(arena);
}
template<> PROTOBUF_NOINLINE ::sp::common::Constant* Arena::CreateMaybeMessage< ::sp::common::Constant >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sp::common::Constant >(arena);
}
template<> PROTOBUF_NOINLINE ::sp::common::SpexHeader* Arena::CreateMaybeMessage< ::sp::common::SpexHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sp::common::SpexHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::sp::common::SpexHeaderQoS* Arena::CreateMaybeMessage< ::sp::common::SpexHeaderQoS >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sp::common::SpexHeaderQoS >(arena);
}
template<> PROTOBUF_NOINLINE ::sp::common::Any* Arena::CreateMaybeMessage< ::sp::common::Any >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sp::common::Any >(arena);
}
template<> PROTOBUF_NOINLINE ::sp::common::Status* Arena::CreateMaybeMessage< ::sp::common::Status >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sp::common::Status >(arena);
}
template<> PROTOBUF_NOINLINE ::sp::common::KeepAliveRequest* Arena::CreateMaybeMessage< ::sp::common::KeepAliveRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sp::common::KeepAliveRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::sp::common::KeepAliveResponse* Arena::CreateMaybeMessage< ::sp::common::KeepAliveResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sp::common::KeepAliveResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::sp::common::KV* Arena::CreateMaybeMessage< ::sp::common::KV >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sp::common::KV >(arena);
}
template<> PROTOBUF_NOINLINE ::sp::common::Metadata* Arena::CreateMaybeMessage< ::sp::common::Metadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sp::common::Metadata >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
